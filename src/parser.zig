//! Autogenerated Code.
//! Manual edits may be overwritten on rebuild.

const tknzr = @import("tokenizer.zig");
const Token = tknzr.Token;
const Tokenizer = tknzr.Tokenizer;
const std = @import("std");
const Alloc = std.mem.Allocator;

const ___ = @This();
fn __aToString(comptime a: anytype) []const u8 {
    return @tagName(a); // todo support strings too
}
fn GetResType(comptime aname: []const u8) type {
    if (!@hasDecl(___, aname)) @compileError("unknown type " ++ aname);
    return @field(___, aname);
}
pub fn parse(alloc: *Alloc, code: []const u8, comptime a: anytype) !GetResType(__aToString(a)) {
    const aname = comptime __aToString(a);
    const ResType = GetResType(aname);
    const resfn = @field(___, "parse" ++ aname);

    var parser = Parser.init(alloc, code);
    defer parser.deinit();

    // TODO: @resultLocation().* = â€¦
    const outmain = try resfn(&parser);
    if ((try parser.nextToken())) |tok| {
        std.debug.panic("Remaining token: {}\n", .{tok});
    }
    return outmain;
}
pub const Parser = struct {
    alloc: *Alloc,
    tokenizer: Tokenizer,
    tokens: std.ArrayList(Token),
    tkpos: usize = 0,
    errors: ?[]const u8 = null,
    fn init(alloc: *Alloc, code: []const u8) Parser {
        return .{
            .alloc = alloc,
            .tokenizer = Tokenizer.init(code),
            .tokens = std.ArrayList(Token).init(alloc),
        };
    }
    fn deinit(parser: *Parser) void {
        parser.tokens.deinit();
    }
    fn err(parser: *Parser, message: []const u8) ParseError {
        parser.errors = message;
        return ParseError.ParseError;
    }
    fn nextToken(parser: *Parser) ParseError!?Token {
        if (parser.tkpos >= parser.tokens.items.len) {
            const nextToken_ = parser.tokenizer.next() catch return parser.err("bad token");
            try parser.tokens.append(nextToken_ orelse return null);
        }
        defer parser.tkpos += 1;
        return parser.tokens.items[parser.tkpos];
    }
    fn startBit(parser: Parser) usize {
        return parser.tkpos;
    }
    fn cancelBit(parser: *Parser, prevPos: usize) void {
        parser.tkpos = prevPos;
    }
};

pub const ParseError = error{
    OutOfMemory,
    ParseError,
};

fn _parseToken(parser: *Parser, tokenKind: Token.Type, expectedText: ?[]const u8) ParseError!Token {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const tok = (try parser.nextToken()) orelse return parser.err("err");
    if (tok.kind != tokenKind) return parser.err("err");
    if (expectedText) |txt| if (!std.mem.eql(u8, tok.text, txt)) return parser.err("err");

    return tok;
}

pub const File = _4;
const _4 = []_1;
const _1 = Decl;
const _2 = []const u8;
fn _5(parser: *Parser) ParseError!_4 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    var resAL = std.ArrayList(_1).init(parser.alloc);
    while (true) {
        // :: parse 1 catch break
        try resAL.append(_6(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => break,
        });
        // :: parse 2 catch break
        _ = _7(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => break,
        };
    }
    return resAL.toOwnedSlice();
}
fn _6(parser: *Parser) ParseError!_1 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return try parseDecl(parser);
}
fn _7(parser: *Parser) ParseError!_2 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, ";")).text;
}
pub const parseFile = _5;
pub const Decl = _15;
const _15 = struct {
    name: _11,
    value: _14,
};
const _11 = []const u8;
const _12 = []const u8;
const _14 = *Component;
fn _16(parser: *Parser) ParseError!_15 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _18 = try _17(parser);
    _ = try _19(parser);
    const _21 = try _20(parser);
    return _15{
        .name = _18,
        .value = _21,
    };
}
fn _17(parser: *Parser) ParseError!_11 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .identifier, null)).text;
}
fn _19(parser: *Parser) ParseError!_12 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "=")).text;
}
fn _20(parser: *Parser) ParseError!_14 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _22 = try parseComponent(parser);
    const _23 = try parser.alloc.create(@TypeOf(_22));
    _23.* = _22;
    return _23;
}
pub const parseDecl = _16;
pub const Component = _38;
const _38 = union(enum) {
    or_op: []_38,
    p_op: []_38,
    suffixop: struct { _: *_38, suffixop: _31 },
    decl_ref: _33,
    token_ref: _34,
    parens: _35,
    string: _36,
    magic: _37,
};
const _26 = []const u8;
const _31 = *Suffixop;
const _33 = []const u8;
const _34 = *TokenRef;
const _35 = *Parens;
const _36 = *String;
const _37 = *Magic;
fn _39(parser: *Parser) ParseError!_38 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    var resAL = std.ArrayList(_38).init(parser.alloc);
    _ = _40(parser) catch |e| switch (e) {
        error.OutOfMemory => return e,
        error.ParseError => {},
    }; // optional first joiner
    while (true) {
        try resAL.append(_41(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => return parser.err("last or disallowed"),
        });
        _ = _40(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => break,
        };
    }
    if (resAL.items.len == 0) return parser.err("no items");
    if (resAL.items.len == 1) return resAL.items[0];

    return _38{ .or_op = resAL.toOwnedSlice() };
}
fn _41(parser: *Parser) ParseError!_38 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);
    var resAL = std.ArrayList(_38).init(parser.alloc);
    //_ = _42(parser) catch |e| switch(e) {error.OutOfMemory => return e, error.ParseError => {}}; // optional first joiner
    while (true) {
        try resAL.append(_43(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => break,
        });
        //_ = _42(parser) catch |e| switch(e) {error.OutOfMemory => return e, error.ParseError => break};
    }
    if (resAL.items.len == 0) return parser.err("no items");
    if (resAL.items.len == 1) return resAL.items[0];

    return _38{ .p_op = resAL.toOwnedSlice() };
}
fn _43(parser: *Parser) ParseError!_38 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);
    // 1: parse the structure
    const resc = try _45(parser);
    // 2: parse the suffixop[] and unwrap
    var topUnwrapped = resc;

    while (true) {
        const suffix = _44(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => break,
        };
        const allocated = try parser.alloc.create(@TypeOf(topUnwrapped));
        allocated.* = topUnwrapped;
        topUnwrapped = .{ .suffixop = .{ ._ = allocated, .suffixop = suffix } };
    }
    return topUnwrapped;
}
fn _45(parser: *Parser) ParseError!_38 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);
    blk: {
        return _38{
            .decl_ref = _46(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    blk: {
        return _38{
            .token_ref = _47(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    blk: {
        return _38{
            .parens = _48(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    blk: {
        return _38{
            .string = _49(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    blk: {
        return _38{
            .magic = _50(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    return parser.err("union field not matched f");
}
fn _40(parser: *Parser) ParseError!_26 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "|")).text;
}
fn _44(parser: *Parser) ParseError!_31 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _51 = try parseSuffixop(parser);
    const _52 = try parser.alloc.create(@TypeOf(_51));
    _52.* = _51;
    return _52;
}
fn _46(parser: *Parser) ParseError!_33 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .identifier, null)).text;
}
fn _47(parser: *Parser) ParseError!_34 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _53 = try parseTokenRef(parser);
    const _54 = try parser.alloc.create(@TypeOf(_53));
    _54.* = _53;
    return _54;
}
fn _48(parser: *Parser) ParseError!_35 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _55 = try parseParens(parser);
    const _56 = try parser.alloc.create(@TypeOf(_55));
    _56.* = _55;
    return _56;
}
fn _49(parser: *Parser) ParseError!_36 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _57 = try parseString(parser);
    const _58 = try parser.alloc.create(@TypeOf(_57));
    _58.* = _57;
    return _58;
}
fn _50(parser: *Parser) ParseError!_37 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _59 = try parseMagic(parser);
    const _60 = try parser.alloc.create(@TypeOf(_59));
    _60.* = _59;
    return _60;
}
pub const parseComponent = _39;
pub const TokenRef = _64;
const _64 = struct {
    token: _63,
};
const _61 = []const u8;
const _63 = []const u8;
fn _65(parser: *Parser) ParseError!_64 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    _ = try _66(parser);
    const _68 = try _67(parser);
    return _64{
        .token = _68,
    };
}
fn _66(parser: *Parser) ParseError!_61 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, ":")).text;
}
fn _67(parser: *Parser) ParseError!_63 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .identifier, null)).text;
}
pub const parseTokenRef = _65;
pub const Parens = _72;
const _72 = struct {
    component: _70,
};
const _69 = []const u8;
const _70 = *Component;
const _71 = []const u8;
fn _73(parser: *Parser) ParseError!_72 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    _ = try _74(parser);
    const _76 = try _75(parser);
    _ = try _77(parser);
    return _72{
        .component = _76,
    };
}
fn _74(parser: *Parser) ParseError!_69 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "(")).text;
}
fn _75(parser: *Parser) ParseError!_70 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _78 = try parseComponent(parser);
    const _79 = try parser.alloc.create(@TypeOf(_78));
    _79.* = _78;
    return _79;
}
fn _77(parser: *Parser) ParseError!_71 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, ")")).text;
}
pub const parseParens = _73;
pub const String = _90;
const _90 = struct {
    bits: _87,
};
const _81 = []const u8;
const _87 = []_85;
const _85 = union(enum) {
    string: _82,
    escape: _84,
};
const _82 = []const u8;
const _84 = []const u8;
const _89 = []const u8;
fn _91(parser: *Parser) ParseError!_90 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    _ = try _92(parser);
    const _94 = try _93(parser);
    _ = try _95(parser);
    return _90{
        .bits = _94,
    };
}
fn _92(parser: *Parser) ParseError!_81 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .string_start, null)).text;
}
fn _93(parser: *Parser) ParseError!_87 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    var resAL = std.ArrayList(_85).init(parser.alloc);
    while (true) {
        // :: parse 1 catch break
        try resAL.append(_96(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => break,
        });
        // :: parse 2 catch break
        //_ = _97(parser) catch |e| switch(e) {error.OutOfMemory => return e, error.ParseError => break};
    }
    return resAL.toOwnedSlice();
}
fn _96(parser: *Parser) ParseError!_85 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    blk: {
        return _85{
            .string = _98(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    blk: {
        return _85{
            .escape = _99(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    return parser.err("union field not matched f");
}
fn _98(parser: *Parser) ParseError!_82 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .string, null)).text;
}
fn _99(parser: *Parser) ParseError!_84 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .string_escape, null)).text;
}
fn _95(parser: *Parser) ParseError!_89 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .string_end, null)).text;
}
pub const parseString = _91;
pub const Magic = _110;
const _110 = struct {
    name: _102,
    args: _108,
};
const _100 = []const u8;
const _102 = []const u8;
const _103 = []const u8;
const _108 = []_105;
const _105 = Component;
const _106 = []const u8;
const _109 = []const u8;
fn _111(parser: *Parser) ParseError!_110 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    _ = try _112(parser);
    const _114 = try _113(parser);
    _ = try _115(parser);
    const _117 = try _116(parser);
    _ = try _118(parser);
    return _110{
        .name = _114,
        .args = _117,
    };
}
fn _112(parser: *Parser) ParseError!_100 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "#")).text;
}
fn _113(parser: *Parser) ParseError!_102 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .identifier, null)).text;
}
fn _115(parser: *Parser) ParseError!_103 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "(")).text;
}
fn _116(parser: *Parser) ParseError!_108 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    var resAL = std.ArrayList(_105).init(parser.alloc);
    while (true) {
        // :: parse 1 catch break
        try resAL.append(_119(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => break,
        });
        // :: parse 2 catch break
        _ = _120(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => break,
        };
    }
    return resAL.toOwnedSlice();
}
fn _119(parser: *Parser) ParseError!_105 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return try parseComponent(parser);
}
fn _120(parser: *Parser) ParseError!_106 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, ",")).text;
}
fn _118(parser: *Parser) ParseError!_109 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, ")")).text;
}
pub const parseMagic = _111;
pub const Suffixop = _126;
const _126 = union(enum) {
    nameset: _123,
    array: _124,
    optional: _125,
};
const _123 = *Nameset;
const _124 = *Array;
const _125 = *Optional;
fn _127(parser: *Parser) ParseError!_126 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    blk: {
        return _126{
            .nameset = _128(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    blk: {
        return _126{
            .array = _129(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    blk: {
        return _126{
            .optional = _130(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    return parser.err("union field not matched f");
}
fn _128(parser: *Parser) ParseError!_123 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _131 = try parseNameset(parser);
    const _132 = try parser.alloc.create(@TypeOf(_131));
    _132.* = _131;
    return _132;
}
fn _129(parser: *Parser) ParseError!_124 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _133 = try parseArray(parser);
    const _134 = try parser.alloc.create(@TypeOf(_133));
    _134.* = _133;
    return _134;
}
fn _130(parser: *Parser) ParseError!_125 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _135 = try parseOptional(parser);
    const _136 = try parser.alloc.create(@TypeOf(_135));
    _136.* = _135;
    return _136;
}
pub const parseSuffixop = _127;
pub const Nameset = _142;
const _142 = struct {
    name: _140,
};
const _137 = []const u8;
const _140 = ?_138;
const _138 = []const u8;
const _141 = []const u8;
fn _143(parser: *Parser) ParseError!_142 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    _ = try _144(parser);
    const _146 = try _145(parser);
    _ = try _147(parser);
    return _142{
        .name = _146,
    };
}
fn _144(parser: *Parser) ParseError!_137 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "<")).text;
}
fn _145(parser: *Parser) ParseError!_140 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return _148(parser) catch |e| switch (e) {
        error.OutOfMemory => return e,
        error.ParseError => return null, // note that the called function already cancelBit'd so it's ok
    };
}
fn _148(parser: *Parser) ParseError!_138 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .identifier, null)).text;
}
fn _147(parser: *Parser) ParseError!_141 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, ">")).text;
}
pub const parseNameset = _143;
pub const Array = _153;
const _153 = struct {
    component: _151,
};
const _149 = []const u8;
const _151 = ?_150;
const _150 = *Component;
const _152 = []const u8;
fn _154(parser: *Parser) ParseError!_153 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    _ = try _155(parser);
    const _157 = try _156(parser);
    _ = try _158(parser);
    return _153{
        .component = _157,
    };
}
fn _155(parser: *Parser) ParseError!_149 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "[")).text;
}
fn _156(parser: *Parser) ParseError!_151 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return _159(parser) catch |e| switch (e) {
        error.OutOfMemory => return e,
        error.ParseError => return null, // note that the called function already cancelBit'd so it's ok
    };
}
fn _159(parser: *Parser) ParseError!_150 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _160 = try parseComponent(parser);
    const _161 = try parser.alloc.create(@TypeOf(_160));
    _161.* = _160;
    return _161;
}
fn _158(parser: *Parser) ParseError!_152 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "]")).text;
}
pub const parseArray = _154;
pub const Optional = _162;
const _162 = []const u8;
fn _163(parser: *Parser) ParseError!_162 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "?")).text;
}
pub const parseOptional = _163;
