//! Autogenerated Code.
//! Manual edits may be overwritten on rebuild.

/// file = decl[";"]<decls>;
pub const File = blk: {
    _ = []Decl;
    break :blk _4;
};
/// decl = :identifier<name> "=" component<value>;
pub const Decl = blk: {
    _ = struct {
        name: []const u8,
        value: *Component,
        _start: usize,
        _end: usize,
    };
    break :blk _10;
};
/// component = #operator("|")<or_op> | #operator()<p_op> | #suffix(suffixop)<suffixop> | :identifier<decl_ref> | token_ref | parens | string | magic;
pub const Component = blk: {
    _ = union(enum) {
        or_op: []_25,
        p_op: []_25,
        suffixop: struct { _: *_25, suffixop: *Suffixop },
        decl_ref: []const u8,
        token_ref: *TokenRef,
        parens: *Parens,
        string: *String,
        magic: *Magic,
    };
    break :blk _25;
};
/// token_ref = ":" :identifier<token>;
pub const TokenRef = blk: {
    _ = struct {
        token: []const u8,
        _start: usize,
        _end: usize,
    };
    break :blk _29;
};
/// parens = "(" component ")";
pub const Parens = blk: {
    _ = struct {
        component: *Component,
        _start: usize,
        _end: usize,
    };
    break :blk _33;
};
/// string = :string_start<> (:string | :string_escape<escape>)[]<bits> :string_end<>;
pub const String = blk: {
    _ = struct {
        bits: []union(enum) {
            string: []const u8,
            escape: []const u8,
        },
        _start: usize,
        _end: usize,
    };
    break :blk _44;
};
/// magic = "#" :identifier<name> "(" component[","]<args> ")";
pub const Magic = blk: {
    _ = struct {
        name: []const u8,
        args: []Component,
        _start: usize,
        _end: usize,
    };
    break :blk _55;
};
/// suffixop = nameset | array | optional;
pub const Suffixop = blk: {
    _ = union(enum) {
        nameset: *Nameset,
        array: *Array,
        optional: *Optional,
    };
    break :blk _59;
};
/// nameset = "<" :identifier?<name> ">";
pub const Nameset = blk: {
    _ = struct {
        name: ?[]const u8,
        _start: usize,
        _end: usize,
    };
    break :blk _65;
};
/// array = "[" component? "]";
pub const Array = blk: {
    _ = struct {
        component: ?*Component,
        _start: usize,
        _end: usize,
    };
    break :blk _70;
};
/// optional = "?";
pub const Optional = blk: {
    _ = []const u8;
    break :blk _71;
};

//.
//.
//.
//.
//.
//.
//.
//                 / ...=====================... \
// --------=======<     Implementation below.     >=======--------
//                 \ '''=====================''' /
//.
//.
//.
//.
//.
//.
//.

const State = enum {
    main,
    identifier,
    string,
    string_dblquote,
    string_ending,
    string_ending_dblquote,
    comment,
    number,
};
// why not just a union of name: []const u8?
pub const Token = struct {
    pub const TokenType = enum {
        identifier,
        string_start,
        string,
        string_escape,
        string_end,
        punctuation,
        number,
    };
    kind: TokenType,
    text: []const u8,
    start: usize,
};
pub const Tokenizer = struct {
    state: State,
    text: []const u8,
    current: usize,
    pub fn init(text: []const u8) Tokenizer {
        return .{
            .state = .main,
            .text = text,
            .current = 0,
        };
    }

    fn peek(tkr: Tokenizer) u8 {
        if (tkr.current >= tkr.text.len) return 0;
        return tkr.text[tkr.current];
    }
    fn take(tkr: *Tokenizer) u8 {
        defer tkr.current += 1;
        return tkr.peek();
    }
    fn token(tkr: *Tokenizer, start: usize, ttype: Token.TokenType) Token {
        return .{
            .kind = ttype,
            .text = tkr.text[start..tkr.current],
            .start = start,
        };
    }

    pub fn next(tkr: *Tokenizer) !?Token {
        var start = tkr.current;
        while (true) {
            switch (tkr.state) {
                .main => {
                    switch (tkr.peek()) {
                        0 => return null,
                        'a'...'z', 'A'...'Z', '_', 128...255 => tkr.state = .identifier,
                        '0'...'9' => tkr.state = .number,
                        ' ', '\n', '\t' => _ = {
                            _ = tkr.take();
                            start = tkr.current;
                        },
                        '\'' => {
                            _ = tkr.take();
                            tkr.state = .string;
                            return tkr.token(start, .string_start);
                        },
                        '"' => {
                            _ = tkr.take();
                            tkr.state = .string_dblquote;
                            return tkr.token(start, .string_start);
                        },
                        '/' => {
                            _ = tkr.take();
                            if (tkr.peek() != '/') {
                                return tkr.token(start, .punctuation);
                            }
                            _ = tkr.take();
                            tkr.state = .comment;
                        },
                        else => |char| {
                            inline for ("[]{}();:,=|?<>!#*+/-.") |c| {
                                if (char == c) {
                                    _ = tkr.take();
                                    return tkr.token(start, .punctuation);
                                }
                            }
                            std.debug.panic("Illegal character: `{c}`", .{char});
                            // return error.IllegalCharacter;
                        },
                    }
                },
                .identifier => switch (tkr.peek()) {
                    'a'...'z', 'A'...'Z', '0'...'9', '_', 128...255 => _ = tkr.take(),
                    else => {
                        tkr.state = .main;
                        return tkr.token(start, .identifier);
                    },
                },
                .number => switch (tkr.peek()) {
                    '0'...'9' => _ = tkr.take(),
                    else => {
                        tkr.state = .main;
                        return tkr.token(start, .number);
                    },
                },
                .string => switch (tkr.peek()) {
                    0, '\n' => return error.IllegalCharacter,
                    '\'' => {
                        tkr.state = .string_ending;
                        return tkr.token(start, .string);
                    },
                    else => _ = tkr.take(),
                },
                .string_dblquote => switch (tkr.peek()) {
                    0, '\n' => return error.IllegalCharacter,
                    '"' => {
                        tkr.state = .string_ending_dblquote;
                        return tkr.token(start, .string);
                    },
                    else => _ = tkr.take(),
                },
                .string_ending => switch (tkr.peek()) {
                    '\'' => {
                        tkr.state = .main;
                        _ = tkr.take();
                        return tkr.token(start, .string_end);
                    },
                    else => unreachable, // shouldn't be in this state
                },
                .string_ending_dblquote => switch (tkr.peek()) {
                    '"' => {
                        tkr.state = .main;
                        _ = tkr.take();
                        return tkr.token(start, .string_end);
                    },
                    else => unreachable, // shouldn't be in this state
                },
                .comment => switch (tkr.peek()) {
                    0, '\n' => tkr.state = .main,
                    else => _ = tkr.take(),
                },
            }
        }
    }
};

const std = @import("std");
const Alloc = std.mem.Allocator;

const ___ = @This();
fn __aToString(comptime a: anytype) []const u8 {
    return @tagName(a); // todo support strings too
}
fn GetResType(comptime aname: []const u8) type {
    if (!@hasDecl(___, aname)) @compileError("unknown type " ++ aname);
    return @field(___, aname);
}
pub fn parse(alloc: *Alloc, code: []const u8, comptime a: anytype) !GetResType(__aToString(a)) {
    const aname = comptime __aToString(a);
    const ResType = GetResType(aname);
    const resfn = @field(___, "parse" ++ aname);

    var parser = Parser.init(alloc, code);
    defer parser.deinit();

    // TODO: @resultLocation().* = â€¦
    const outmain = try resfn(&parser);
    if ((try parser.nextToken())) |tok| {
        std.debug.panic("Remaining token: {}\n", .{tok});
    }
    return outmain;
}
pub const Parser = struct {
    alloc: *Alloc,
    tokenizer: Tokenizer,
    tokens: std.ArrayList(Token),
    tkpos: usize = 0,
    cpos: usize = 0,
    errors: ?[]const u8 = null,
    fn init(alloc: *Alloc, code: []const u8) Parser {
        return .{
            .alloc = alloc,
            .tokenizer = Tokenizer.init(code),
            .tokens = std.ArrayList(Token).init(alloc),
        };
    }
    fn deinit(parser: *Parser) void {
        parser.tokens.deinit();
    }
    fn err(parser: *Parser, message: []const u8) ParseError {
        parser.errors = message;
        return ParseError.ParseError;
    }
    fn nextToken(parser: *Parser) ParseError!?Token {
        if (parser.tkpos >= parser.tokens.items.len) {
            const nextToken_ = parser.tokenizer.next() catch return parser.err("bad token");
            try parser.tokens.append(nextToken_ orelse return null);
        }
        defer parser.tkpos += 1;

        const restoken = parser.tokens.items[parser.tkpos];
        parser.cpos = restoken.start + restoken.text.len;
        return restoken;
    }
    fn startBit(parser: Parser) usize {
        return parser.tkpos;
    }
    fn cancelBit(parser: *Parser, prevPos: usize) void {
        parser.tkpos = prevPos;

        if (parser.tkpos == 0) parser.cpos = 0 else {
            const restoken = parser.tokens.items[parser.tkpos - 1];
            parser.cpos = restoken.start + restoken.text.len;
        }
    }
};

pub const ParseError = error{
    OutOfMemory,
    ParseError,
};

fn _parseToken(parser: *Parser, tokenKind: Token.TokenType, expectedText: ?[]const u8) ParseError!Token {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const tok = (try parser.nextToken()) orelse return parser.err("err");
    if (tok.kind != tokenKind) return parser.err("err");
    if (expectedText) |txt| if (!std.mem.eql(u8, tok.text, txt)) return parser.err("err");

    return tok;
}

const _4 = []_1;
const _1 = Decl;
const _2 = []const u8;
fn _72(parser: *Parser) ParseError!_4 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    var resAL = std.ArrayList(_1).init(parser.alloc);
    while (true) {
        // :: parse 1 catch break
        try resAL.append(_73(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => break,
        });
        // :: parse 2 catch break
        _ = _74(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => break,
        };
    }
    return resAL.toOwnedSlice();
}
fn _73(parser: *Parser) ParseError!_1 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return try parseDecl(parser);
}
fn _74(parser: *Parser) ParseError!_2 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, ";")).text;
}
pub const parseFile = _72;
const _10 = struct {
    name: _6,
    value: _9,
    _start: usize,
    _end: usize,
};
const _6 = []const u8;
const _7 = []const u8;
const _9 = *Component;
fn _77(parser: *Parser) ParseError!_10 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const start = parser.cpos;
    const _79 = try _78(parser);
    _ = try _80(parser);
    const _82 = try _81(parser);
    const end = parser.cpos;
    return _10{
        .name = _79,
        .value = _82,
        ._start = start,
        ._end = end,
    };
}
fn _78(parser: *Parser) ParseError!_6 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .identifier, null)).text;
}
fn _80(parser: *Parser) ParseError!_7 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "=")).text;
}
fn _81(parser: *Parser) ParseError!_9 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _83 = try parseComponent(parser);
    const _84 = try parser.alloc.create(@TypeOf(_83));
    _84.* = _83;
    return _84;
}
pub const parseDecl = _77;
const _25 = union(enum) {
    or_op: []_25,
    p_op: []_25,
    suffixop: struct { _: *_25, suffixop: _18 },
    decl_ref: _20,
    token_ref: _21,
    parens: _22,
    string: _23,
    magic: _24,
};
const _13 = []const u8;
const _18 = *Suffixop;
const _20 = []const u8;
const _21 = *TokenRef;
const _22 = *Parens;
const _23 = *String;
const _24 = *Magic;
fn _85(parser: *Parser) ParseError!_25 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    var resAL = std.ArrayList(_25).init(parser.alloc);
    _ = _86(parser) catch |e| switch (e) {
        error.OutOfMemory => return e,
        error.ParseError => {},
    }; // optional first joiner
    while (true) {
        try resAL.append(_87(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => return parser.err("last or disallowed"),
        });
        _ = _86(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => break,
        };
    }
    if (resAL.items.len == 0) return parser.err("no items");
    if (resAL.items.len == 1) return resAL.items[0];

    return _25{ .or_op = resAL.toOwnedSlice() };
}
fn _87(parser: *Parser) ParseError!_25 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);
    var resAL = std.ArrayList(_25).init(parser.alloc);
    //_ = _88(parser) catch |e| switch(e) {error.OutOfMemory => return e, error.ParseError => {}}; // optional first joiner
    while (true) {
        try resAL.append(_89(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => break,
        });
        //_ = _88(parser) catch |e| switch(e) {error.OutOfMemory => return e, error.ParseError => break};
    }
    if (resAL.items.len == 0) return parser.err("no items");
    if (resAL.items.len == 1) return resAL.items[0];

    return _25{ .p_op = resAL.toOwnedSlice() };
}
fn _89(parser: *Parser) ParseError!_25 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);
    // 1: parse the structure
    const resc = try _91(parser);
    // 2: parse the suffixop[] and unwrap
    var topUnwrapped = resc;

    while (true) {
        const suffix = _90(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => break,
        };
        const allocated = try parser.alloc.create(@TypeOf(topUnwrapped));
        allocated.* = topUnwrapped;
        topUnwrapped = .{ .suffixop = .{ ._ = allocated, .suffixop = suffix } };
    }
    return topUnwrapped;
}
fn _91(parser: *Parser) ParseError!_25 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);
    blk: {
        return _25{
            .decl_ref = _92(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    blk: {
        return _25{
            .token_ref = _93(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    blk: {
        return _25{
            .parens = _94(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    blk: {
        return _25{
            .string = _95(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    blk: {
        return _25{
            .magic = _96(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    return parser.err("union field not matched f");
}
fn _86(parser: *Parser) ParseError!_13 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "|")).text;
}
fn _90(parser: *Parser) ParseError!_18 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _97 = try parseSuffixop(parser);
    const _98 = try parser.alloc.create(@TypeOf(_97));
    _98.* = _97;
    return _98;
}
fn _92(parser: *Parser) ParseError!_20 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .identifier, null)).text;
}
fn _93(parser: *Parser) ParseError!_21 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _99 = try parseTokenRef(parser);
    const _100 = try parser.alloc.create(@TypeOf(_99));
    _100.* = _99;
    return _100;
}
fn _94(parser: *Parser) ParseError!_22 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _101 = try parseParens(parser);
    const _102 = try parser.alloc.create(@TypeOf(_101));
    _102.* = _101;
    return _102;
}
fn _95(parser: *Parser) ParseError!_23 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _103 = try parseString(parser);
    const _104 = try parser.alloc.create(@TypeOf(_103));
    _104.* = _103;
    return _104;
}
fn _96(parser: *Parser) ParseError!_24 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _105 = try parseMagic(parser);
    const _106 = try parser.alloc.create(@TypeOf(_105));
    _106.* = _105;
    return _106;
}
pub const parseComponent = _85;
const _29 = struct {
    token: _28,
    _start: usize,
    _end: usize,
};
const _26 = []const u8;
const _28 = []const u8;
fn _107(parser: *Parser) ParseError!_29 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const start = parser.cpos;
    _ = try _108(parser);
    const _110 = try _109(parser);
    const end = parser.cpos;
    return _29{
        .token = _110,
        ._start = start,
        ._end = end,
    };
}
fn _108(parser: *Parser) ParseError!_26 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, ":")).text;
}
fn _109(parser: *Parser) ParseError!_28 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .identifier, null)).text;
}
pub const parseTokenRef = _107;
const _33 = struct {
    component: _31,
    _start: usize,
    _end: usize,
};
const _30 = []const u8;
const _31 = *Component;
const _32 = []const u8;
fn _111(parser: *Parser) ParseError!_33 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const start = parser.cpos;
    _ = try _112(parser);
    const _114 = try _113(parser);
    _ = try _115(parser);
    const end = parser.cpos;
    return _33{
        .component = _114,
        ._start = start,
        ._end = end,
    };
}
fn _112(parser: *Parser) ParseError!_30 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "(")).text;
}
fn _113(parser: *Parser) ParseError!_31 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _116 = try parseComponent(parser);
    const _117 = try parser.alloc.create(@TypeOf(_116));
    _117.* = _116;
    return _117;
}
fn _115(parser: *Parser) ParseError!_32 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, ")")).text;
}
pub const parseParens = _111;
const _44 = struct {
    bits: _41,
    _start: usize,
    _end: usize,
};
const _35 = []const u8;
const _41 = []_39;
const _39 = union(enum) {
    string: _36,
    escape: _38,
};
const _36 = []const u8;
const _38 = []const u8;
const _43 = []const u8;
fn _118(parser: *Parser) ParseError!_44 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const start = parser.cpos;
    _ = try _119(parser);
    const _121 = try _120(parser);
    _ = try _122(parser);
    const end = parser.cpos;
    return _44{
        .bits = _121,
        ._start = start,
        ._end = end,
    };
}
fn _119(parser: *Parser) ParseError!_35 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .string_start, null)).text;
}
fn _120(parser: *Parser) ParseError!_41 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    var resAL = std.ArrayList(_39).init(parser.alloc);
    while (true) {
        // :: parse 1 catch break
        try resAL.append(_123(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => break,
        });
        // :: parse 2 catch break
        //_ = _124(parser) catch |e| switch(e) {error.OutOfMemory => return e, error.ParseError => break};
    }
    return resAL.toOwnedSlice();
}
fn _123(parser: *Parser) ParseError!_39 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    blk: {
        return _39{
            .string = _125(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    blk: {
        return _39{
            .escape = _126(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    return parser.err("union field not matched f");
}
fn _125(parser: *Parser) ParseError!_36 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .string, null)).text;
}
fn _126(parser: *Parser) ParseError!_38 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .string_escape, null)).text;
}
fn _122(parser: *Parser) ParseError!_43 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .string_end, null)).text;
}
pub const parseString = _118;
const _55 = struct {
    name: _47,
    args: _53,
    _start: usize,
    _end: usize,
};
const _45 = []const u8;
const _47 = []const u8;
const _48 = []const u8;
const _53 = []_50;
const _50 = Component;
const _51 = []const u8;
const _54 = []const u8;
fn _127(parser: *Parser) ParseError!_55 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const start = parser.cpos;
    _ = try _128(parser);
    const _130 = try _129(parser);
    _ = try _131(parser);
    const _133 = try _132(parser);
    _ = try _134(parser);
    const end = parser.cpos;
    return _55{
        .name = _130,
        .args = _133,
        ._start = start,
        ._end = end,
    };
}
fn _128(parser: *Parser) ParseError!_45 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "#")).text;
}
fn _129(parser: *Parser) ParseError!_47 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .identifier, null)).text;
}
fn _131(parser: *Parser) ParseError!_48 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "(")).text;
}
fn _132(parser: *Parser) ParseError!_53 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    var resAL = std.ArrayList(_50).init(parser.alloc);
    while (true) {
        // :: parse 1 catch break
        try resAL.append(_135(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => break,
        });
        // :: parse 2 catch break
        _ = _136(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => break,
        };
    }
    return resAL.toOwnedSlice();
}
fn _135(parser: *Parser) ParseError!_50 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return try parseComponent(parser);
}
fn _136(parser: *Parser) ParseError!_51 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, ",")).text;
}
fn _134(parser: *Parser) ParseError!_54 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, ")")).text;
}
pub const parseMagic = _127;
const _59 = union(enum) {
    nameset: _56,
    array: _57,
    optional: _58,
};
const _56 = *Nameset;
const _57 = *Array;
const _58 = *Optional;
fn _139(parser: *Parser) ParseError!_59 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    blk: {
        return _59{
            .nameset = _140(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    blk: {
        return _59{
            .array = _141(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    blk: {
        return _59{
            .optional = _142(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    return parser.err("union field not matched f");
}
fn _140(parser: *Parser) ParseError!_56 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _143 = try parseNameset(parser);
    const _144 = try parser.alloc.create(@TypeOf(_143));
    _144.* = _143;
    return _144;
}
fn _141(parser: *Parser) ParseError!_57 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _145 = try parseArray(parser);
    const _146 = try parser.alloc.create(@TypeOf(_145));
    _146.* = _145;
    return _146;
}
fn _142(parser: *Parser) ParseError!_58 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _147 = try parseOptional(parser);
    const _148 = try parser.alloc.create(@TypeOf(_147));
    _148.* = _147;
    return _148;
}
pub const parseSuffixop = _139;
const _65 = struct {
    name: _63,
    _start: usize,
    _end: usize,
};
const _60 = []const u8;
const _63 = ?_61;
const _61 = []const u8;
const _64 = []const u8;
fn _149(parser: *Parser) ParseError!_65 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const start = parser.cpos;
    _ = try _150(parser);
    const _152 = try _151(parser);
    _ = try _153(parser);
    const end = parser.cpos;
    return _65{
        .name = _152,
        ._start = start,
        ._end = end,
    };
}
fn _150(parser: *Parser) ParseError!_60 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "<")).text;
}
fn _151(parser: *Parser) ParseError!_63 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return _154(parser) catch |e| switch (e) {
        error.OutOfMemory => return e,
        error.ParseError => return null, // note that the called function already cancelBit'd so it's ok
    };
}
fn _154(parser: *Parser) ParseError!_61 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .identifier, null)).text;
}
fn _153(parser: *Parser) ParseError!_64 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, ">")).text;
}
pub const parseNameset = _149;
const _70 = struct {
    component: _68,
    _start: usize,
    _end: usize,
};
const _66 = []const u8;
const _68 = ?_67;
const _67 = *Component;
const _69 = []const u8;
fn _155(parser: *Parser) ParseError!_70 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const start = parser.cpos;
    _ = try _156(parser);
    const _158 = try _157(parser);
    _ = try _159(parser);
    const end = parser.cpos;
    return _70{
        .component = _158,
        ._start = start,
        ._end = end,
    };
}
fn _156(parser: *Parser) ParseError!_66 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "[")).text;
}
fn _157(parser: *Parser) ParseError!_68 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return _160(parser) catch |e| switch (e) {
        error.OutOfMemory => return e,
        error.ParseError => return null, // note that the called function already cancelBit'd so it's ok
    };
}
fn _160(parser: *Parser) ParseError!_67 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _161 = try parseComponent(parser);
    const _162 = try parser.alloc.create(@TypeOf(_161));
    _162.* = _161;
    return _162;
}
fn _159(parser: *Parser) ParseError!_69 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "]")).text;
}
pub const parseArray = _155;
const _71 = []const u8;
fn _163(parser: *Parser) ParseError!_71 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "?")).text;
}
pub const parseOptional = _163;
