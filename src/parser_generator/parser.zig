//! Autogenerated Code.
//! Manual edits may be overwritten on rebuild.

/// file = decl[";"]<decls>;
const _File = []Decl;
pub const File = _4;

/// decl = :identifier<name> "=" component<value>;
const _Decl = struct {
    name: []const u8,
    // <unnamed>: …
    value: *Component,

    _start: usize,
    _end: usize,
};
pub const Decl = _10;

/// component = #operator("|")<or_op> | #operator()<p_op> | #suffix(suffixop) | :identifier<decl_ref> | token_ref | parens | string | magic | force_struct;
const _Component = union(enum) {
    or_op: []_25,
    p_op: []_25,
    suffixop: struct { _: *_25, suffixop: *Suffixop },
    decl_ref: []const u8,
    token_ref: *TokenRef,
    parens: *Parens,
    string: *String,
    magic: *Magic,
    force_struct: *ForceStruct,
};
pub const Component = _25;

/// token_ref = ":" #lockin() :identifier<token>;
const _TokenRef = struct {
    // <unnamed>: …
    // <lockin past this point>
    token: []const u8,

    _start: usize,
    _end: usize,
};
pub const TokenRef = _30;

/// parens = "(" #lockin() component ")";
const _Parens = struct {
    // <unnamed>: …
    // <lockin past this point>
    component: *Component,
    // <unnamed>: …

    _start: usize,
    _end: usize,
};
pub const Parens = _35;

/// string = :string_start<> #lockin() (:string | :string_escape<escape>)[]<bits> :string_end<>;
const _String = struct {
    // <unnamed>: …
    // <lockin past this point>
    bits: []union(enum) {
        string: []const u8,
        escape: []const u8,
    },
    // <unnamed>: …

    _start: usize,
    _end: usize,
};
pub const String = _47;

/// magic = "#" #lockin() :identifier<name> "(" component[","]<args> ")";
const _Magic = struct {
    // <unnamed>: …
    // <lockin past this point>
    name: []const u8,
    // <unnamed>: …
    args: []Component,
    // <unnamed>: …

    _start: usize,
    _end: usize,
};
pub const Magic = _59;

/// suffixop = nameset | array | optional;
const _Suffixop = union(enum) {
    nameset: *Nameset,
    array: *Array,
    optional: *Optional,
};
pub const Suffixop = _63;

/// nameset = "<" #lockin() :identifier?<name> ">";
const _Nameset = struct {
    // <unnamed>: …
    // <lockin past this point>
    name: ?[]const u8,
    // <unnamed>: …

    _start: usize,
    _end: usize,
};
pub const Nameset = _70;

/// array = "[" #lockin() component? "]";
const _Array = struct {
    // <unnamed>: …
    // <lockin past this point>
    component: ?*Component,
    // <unnamed>: …

    _start: usize,
    _end: usize,
};
pub const Array = _76;

/// optional = "?";
const _Optional = []const u8;
pub const Optional = _77;

/// force_struct = ".";
const _ForceStruct = []const u8;
pub const ForceStruct = _78;

//.
//.
//.
//.
//.
//.
//.
//                 / ...=====================... \
// --------=======<     Implementation below.     >=======--------
//                 \ '''=====================''' /
//.
//.
//.
//.
//.
//.
//.

const State = enum {
    main,
    identifier,
    string,
    string_dblquote,
    string_ending,
    string_ending_dblquote,
    comment,
    number,
};
// why not just a union of name: []const u8?
pub const Token = struct {
    pub const TokenType = enum {
        identifier,
        string_start,
        string,
        string_escape,
        string_end,
        punctuation,
        number,
    };
    kind: TokenType,
    text: []const u8,
    start: usize,
};
pub const Tokenizer = struct {
    state: State,
    text: []const u8,
    current: usize,
    pub fn init(text: []const u8) Tokenizer {
        return .{
            .state = .main,
            .text = text,
            .current = 0,
        };
    }

    fn peek(tkr: Tokenizer) u8 {
        if (tkr.current >= tkr.text.len) return 0;
        return tkr.text[tkr.current];
    }
    fn take(tkr: *Tokenizer) u8 {
        defer tkr.current += 1;
        return tkr.peek();
    }
    fn token(tkr: *Tokenizer, start: usize, ttype: Token.TokenType) Token {
        return .{
            .kind = ttype,
            .text = tkr.text[start..tkr.current],
            .start = start,
        };
    }

    pub fn next(tkr: *Tokenizer) !?Token {
        var start = tkr.current;
        while (true) {
            switch (tkr.state) {
                .main => {
                    switch (tkr.peek()) {
                        0 => return null,
                        'a'...'z', 'A'...'Z', '_', 128...255 => tkr.state = .identifier,
                        '0'...'9' => tkr.state = .number,
                        ' ', '\n', '\t' => _ = {
                            _ = tkr.take();
                            start = tkr.current;
                        },
                        '\'' => {
                            _ = tkr.take();
                            tkr.state = .string;
                            return tkr.token(start, .string_start);
                        },
                        '"' => {
                            _ = tkr.take();
                            tkr.state = .string_dblquote;
                            return tkr.token(start, .string_start);
                        },
                        '/' => {
                            _ = tkr.take();
                            if (tkr.peek() != '/') {
                                return tkr.token(start, .punctuation);
                            }
                            _ = tkr.take();
                            tkr.state = .comment;
                        },
                        else => |char| {
                            inline for ("[]{}();:,=|?<>!#*+/-.") |c| {
                                if (char == c) {
                                    _ = tkr.take();
                                    return tkr.token(start, .punctuation);
                                }
                            }
                            std.debug.panic("Illegal character: `{c}`", .{char});
                            // return error.IllegalCharacter;
                        },
                    }
                },
                .identifier => switch (tkr.peek()) {
                    'a'...'z', 'A'...'Z', '0'...'9', '_', 128...255 => _ = tkr.take(),
                    else => {
                        tkr.state = .main;
                        return tkr.token(start, .identifier);
                    },
                },
                .number => switch (tkr.peek()) {
                    '0'...'9' => _ = tkr.take(),
                    else => {
                        tkr.state = .main;
                        return tkr.token(start, .number);
                    },
                },
                .string => switch (tkr.peek()) {
                    0, '\n' => return error.IllegalCharacter,
                    '\'' => {
                        tkr.state = .string_ending;
                        return tkr.token(start, .string);
                    },
                    else => _ = tkr.take(),
                },
                .string_dblquote => switch (tkr.peek()) {
                    0, '\n' => return error.IllegalCharacter,
                    '"' => {
                        tkr.state = .string_ending_dblquote;
                        return tkr.token(start, .string);
                    },
                    else => _ = tkr.take(),
                },
                .string_ending => switch (tkr.peek()) {
                    '\'' => {
                        tkr.state = .main;
                        _ = tkr.take();
                        return tkr.token(start, .string_end);
                    },
                    else => unreachable, // shouldn't be in this state
                },
                .string_ending_dblquote => switch (tkr.peek()) {
                    '"' => {
                        tkr.state = .main;
                        _ = tkr.take();
                        return tkr.token(start, .string_end);
                    },
                    else => unreachable, // shouldn't be in this state
                },
                .comment => switch (tkr.peek()) {
                    0, '\n' => tkr.state = .main,
                    else => _ = tkr.take(),
                },
            }
        }
    }
};

const std = @import("std");
const Alloc = std.mem.Allocator;

const ___ = @This();
fn __aToString(comptime a: anytype) []const u8 {
    return @tagName(a); // todo support strings too
}
fn GetResType(comptime aname: []const u8) type {
    if (!@hasDecl(___, aname)) @compileError("unknown type " ++ aname);
    return @field(___, aname);
}

pub fn printSyntaxHighlight(text: []const u8, out: anytype) @TypeOf(out).Error!void {
    var tokenizer = Tokenizer.init(text);
    while (true) {
        const start = tokenizer.current;
        const nextToken = tokenizer.next() catch {
            try out.print("\x1b[31m{s}\x1b(B\x1b[m", .{tokenizer.text[start..]});
            break;
        };
        const token = nextToken orelse break;
        const here = tokenizer.current;
        switch (token.kind) {
            .identifier => try out.writeAll("\x1b[97m"),
            .string_start => try out.writeAll("\x1b[32m"),
            .string_end => try out.writeAll("\x1b[32m"),
            .string => try out.writeAll("\x1b[92m"),
            .string_escape => try out.writeAll("\x1b[94m"),
            .punctuation => try out.writeAll(""),
            .number => try out.writeAll("\x1b[96m"),
        }
        for (tokenizer.text[start..here]) |char| {
            switch (char) {
                '\t' => try out.writeAll("    "),
                else => try out.writeByte(char),
            }
        }
        try out.writeAll("\x1b(B\x1b[m");
    }
}

pub fn printErrorPos(text: []const u8, message: []const u8, epos: usize, out: anytype) @TypeOf(out).Error!void {
    // todo rewrite this to be sane
    var lyn: usize = 0;
    var col: usize = 0;
    var latestLine: usize = 0;
    for (text) |char, i| {
        if (epos == i) break;
        col += 1;
        if (char == '\n') {
            lyn += 1;
            col = 0;
            latestLine = i + 1;
        }
    }
    var lineText = std.mem.span(@ptrCast([*:'\n']const u8, &text[latestLine]));
    try out.print("\x1b[1m\x1b[97m./file:{}:{}: \x1b[31merror: \x1b[97m{s}\x1b(B\x1b[m\n", .{ lyn + 1, col + 1, message });
    // would it be bad to tokenize and syntax highlight lineText?
    try printSyntaxHighlight(lineText, out);
    try out.print("\x1b(B\x1b[m\n", .{});
    var i: usize = 0;
    while (i < col) : (i += 1) {
        switch (lineText[i]) {
            '\t' => try out.print("    ", .{}),
            else => try out.print(" ", .{}),
        }
    }
    try out.print("^\n", .{});
}
pub fn parse(alloc: *Alloc, code: []const u8, comptime a: anytype) !GetResType(__aToString(a)) {
    const aname = comptime __aToString(a);
    const ResType = GetResType(aname);
    const resfn = @field(___, "parse" ++ aname);

    var parser = Parser.init(alloc, code);
    defer parser.deinit();

    const out = std.io.getStdErr().writer();

    // TODO: @resultLocation().* = …
    const outmain = resfn(&parser) catch |e| switch (e) {
        error.OutOfMemory => return e,
        error.Recoverable, error.Unrecoverable => {
            if (parser.unrecoverableStats) |stats| {
                try printErrorPos(parser.tokenizer.text, stats.message, stats.pos, out);
                try printErrorPos(parser.tokenizer.text, "(farthest)", parser.farthest, out);
            } else {
                try printErrorPos(parser.tokenizer.text, parser.errors.?, parser.farthest, out);
            }
            std.debug.panic("Parsing failed\n", .{});
        },
    };
    if ((try parser.nextToken())) |tok| {
        std.debug.panic("Remaining token: {}\n", .{tok});
    }
    return outmain;
}
pub const Parser = struct {
    alloc: *Alloc,
    tokenizer: Tokenizer,
    tokens: std.ArrayList(Token),
    tkpos: usize = 0,
    cpos: usize = 0,
    farthest: usize = 0,
    errors: ?[]const u8 = null,
    unrecoverableStats: ?struct {
        pos: usize,
        farthest: usize,
        message: []const u8,
    } = null,
    fn init(alloc: *Alloc, code: []const u8) Parser {
        return .{
            .alloc = alloc,
            .tokenizer = Tokenizer.init(code),
            .tokens = std.ArrayList(Token).init(alloc),
        };
    }
    fn deinit(parser: *Parser) void {
        parser.tokens.deinit();
    }
    fn err(parser: *Parser, message: []const u8) ParseError {
        parser.errors = message;
        return ParseError.Recoverable;
    }
    fn unrecoverableError(parser: *Parser, message: []const u8) ParseError {
        parser.errors = message;
        parser.unrecoverableStats = .{
            .pos = parser.cpos,
            .message = message,
            .farthest = parser.farthest,
        };
        return ParseError.Unrecoverable;
    }
    fn nextToken(parser: *Parser) ParseError!?Token {
        if (parser.tkpos >= parser.tokens.items.len) {
            const nextToken_ = parser.tokenizer.next() catch return parser.unrecoverableError("bad token");
            try parser.tokens.append(nextToken_ orelse return null);
        }
        defer parser.tkpos += 1;

        const restoken = parser.tokens.items[parser.tkpos];
        parser.cpos = restoken.start + restoken.text.len;
        parser.farthest = parser.cpos;
        return restoken;
    }
    fn startBit(parser: Parser) usize {
        return parser.tkpos;
    }
    fn cancelBit(parser: *Parser, prevPos: usize) void {
        parser.tkpos = prevPos;

        if (parser.tkpos == 0) parser.cpos = 0 else {
            const restoken = parser.tokens.items[parser.tkpos - 1];
            parser.cpos = restoken.start + restoken.text.len;
        }
    }
};

pub const ParseError = error{
    Unrecoverable,
    OutOfMemory,
    Recoverable,
};

fn _parseToken(parser: *Parser, tokenKind: Token.TokenType, expectedText: ?[]const u8) ParseError!Token {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const tok = (try parser.nextToken()) orelse return parser.err("err");
    if (tok.kind != tokenKind) return parser.err("err");
    if (expectedText) |txt| if (!std.mem.eql(u8, tok.text, txt)) return parser.err("err");

    return tok;
}

const _4 = []_1;
const _1 = Decl;
const _2 = []const u8;
fn _79(parser: *Parser) ParseError!_4 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    var resAL = std.ArrayList(_1).init(parser.alloc);
    while (true) {
        // :: parse 1 catch break
        try resAL.append(_80(parser) catch |e| switch (e) {
            else => return e,
            error.Recoverable => break,
        });
        // :: parse 2 catch break
        _ = _81(parser) catch |e| switch (e) {
            else => return e,
            error.Recoverable => break,
        };
    }
    return resAL.toOwnedSlice();
}
fn _80(parser: *Parser) ParseError!_1 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return try parseDecl(parser);
}
fn _81(parser: *Parser) ParseError!_2 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, ";")).text;
}
pub const parseFile = _79;
const _10 = struct {
    name: _6,
    // <unnamed>: …
    value: _9,

    _start: usize,
    _end: usize,
};
const _6 = []const u8;
const _7 = []const u8;
const _9 = *Component;
fn _84(parser: *Parser) ParseError!_10 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const start = parser.cpos;
    const _86 = try _85(parser);
    _ = try _87(parser);
    const _89 = try _88(parser);
    const end = parser.cpos;
    return _10{
        .name = _86,
        .value = _89,
        ._start = start,
        ._end = end,
    };
}
fn _85(parser: *Parser) ParseError!_6 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .identifier, null)).text;
}
fn _87(parser: *Parser) ParseError!_7 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "=")).text;
}
fn _88(parser: *Parser) ParseError!_9 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _90 = try parseComponent(parser);
    const _91 = try parser.alloc.create(@TypeOf(_90));
    _91.* = _90;
    return _91;
}
pub const parseDecl = _84;
const _25 = union(enum) {
    or_op: []_25,
    p_op: []_25,
    suffixop: struct { _: *_25, suffixop: _16 },
    decl_ref: _19,
    token_ref: _20,
    parens: _21,
    string: _22,
    magic: _23,
    force_struct: _24,
};
const _11 = []const u8;
const _16 = *Suffixop;
const _19 = []const u8;
const _20 = *TokenRef;
const _21 = *Parens;
const _22 = *String;
const _23 = *Magic;
const _24 = *ForceStruct;
fn _92(parser: *Parser) ParseError!_25 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    var resAL = std.ArrayList(_25).init(parser.alloc);
    _ = _93(parser) catch |e| switch (e) {
        else => return e,
        error.Recoverable => {},
    }; // optional first joiner
    while (true) {
        try resAL.append(_94(parser) catch |e| switch (e) {
            else => return e,
            error.Recoverable => return parser.err("last or disallowed"),
        });
        _ = _93(parser) catch |e| switch (e) {
            else => return e,
            error.Recoverable => break,
        };
    }
    if (resAL.items.len == 0) return parser.err("no items");
    if (resAL.items.len == 1) return resAL.items[0];

    return _25{ .or_op = resAL.toOwnedSlice() };
}
fn _94(parser: *Parser) ParseError!_25 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);
    var resAL = std.ArrayList(_25).init(parser.alloc);
    //_ = _95(parser) catch |e| switch(e) {else => return e, error.Recoverable => {}}; // optional first joiner
    while (true) {
        try resAL.append(_96(parser) catch |e| switch (e) {
            else => return e,
            error.Recoverable => break,
        });
        //_ = _95(parser) catch |e| switch(e) {else => return e, error.Recoverable => break};
    }
    if (resAL.items.len == 0) return parser.err("no items");
    if (resAL.items.len == 1) return resAL.items[0];

    return _25{ .p_op = resAL.toOwnedSlice() };
}
fn _96(parser: *Parser) ParseError!_25 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);
    // 1: parse the structure
    const resc = try _98(parser);
    // 2: parse the suffixop[] and unwrap
    var topUnwrapped = resc;

    while (true) {
        const suffix = _97(parser) catch |e| switch (e) {
            else => return e,
            error.Recoverable => break,
        };
        const allocated = try parser.alloc.create(@TypeOf(topUnwrapped));
        allocated.* = topUnwrapped;
        topUnwrapped = .{ .suffixop = .{ ._ = allocated, .suffixop = suffix } };
    }
    return topUnwrapped;
}
fn _98(parser: *Parser) ParseError!_25 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);
    blk: {
        return _25{
            .decl_ref = _99(parser) catch |e| switch (e) {
                else => return e,
                error.Recoverable => break :blk,
            },
        };
    }
    blk: {
        return _25{
            .token_ref = _100(parser) catch |e| switch (e) {
                else => return e,
                error.Recoverable => break :blk,
            },
        };
    }
    blk: {
        return _25{
            .parens = _101(parser) catch |e| switch (e) {
                else => return e,
                error.Recoverable => break :blk,
            },
        };
    }
    blk: {
        return _25{
            .string = _102(parser) catch |e| switch (e) {
                else => return e,
                error.Recoverable => break :blk,
            },
        };
    }
    blk: {
        return _25{
            .magic = _103(parser) catch |e| switch (e) {
                else => return e,
                error.Recoverable => break :blk,
            },
        };
    }
    blk: {
        return _25{
            .force_struct = _104(parser) catch |e| switch (e) {
                else => return e,
                error.Recoverable => break :blk,
            },
        };
    }
    return parser.err("union field not matched f");
}
fn _93(parser: *Parser) ParseError!_11 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "|")).text;
}
fn _97(parser: *Parser) ParseError!_16 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _105 = try parseSuffixop(parser);
    const _106 = try parser.alloc.create(@TypeOf(_105));
    _106.* = _105;
    return _106;
}
fn _99(parser: *Parser) ParseError!_19 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .identifier, null)).text;
}
fn _100(parser: *Parser) ParseError!_20 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _107 = try parseTokenRef(parser);
    const _108 = try parser.alloc.create(@TypeOf(_107));
    _108.* = _107;
    return _108;
}
fn _101(parser: *Parser) ParseError!_21 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _109 = try parseParens(parser);
    const _110 = try parser.alloc.create(@TypeOf(_109));
    _110.* = _109;
    return _110;
}
fn _102(parser: *Parser) ParseError!_22 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _111 = try parseString(parser);
    const _112 = try parser.alloc.create(@TypeOf(_111));
    _112.* = _111;
    return _112;
}
fn _103(parser: *Parser) ParseError!_23 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _113 = try parseMagic(parser);
    const _114 = try parser.alloc.create(@TypeOf(_113));
    _114.* = _113;
    return _114;
}
fn _104(parser: *Parser) ParseError!_24 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _115 = try parseForceStruct(parser);
    const _116 = try parser.alloc.create(@TypeOf(_115));
    _116.* = _115;
    return _116;
}
pub const parseComponent = _92;
const _30 = struct {
    // <unnamed>: …
    // <lockin past this point>
    token: _29,

    _start: usize,
    _end: usize,
};
const _26 = []const u8;
const _29 = []const u8;
fn _117(parser: *Parser) ParseError!_30 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const start = parser.cpos;
    _ = try _118(parser);
    return _119(parser, start) catch |e| switch (e) {
        error.Recoverable => return parser.unrecoverableError("lockin failed (120)"),
        else => return e,
    };
}
fn _119(parser: *Parser, start: usize) ParseError!_30 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);
    const _122 = try _121(parser);
    const end = parser.cpos;
    return _30{
        .token = _122,
        ._start = start,
        ._end = end,
    };
}
fn _118(parser: *Parser) ParseError!_26 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, ":")).text;
}
fn _121(parser: *Parser) ParseError!_29 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .identifier, null)).text;
}
pub const parseTokenRef = _117;
const _35 = struct {
    // <unnamed>: …
    // <lockin past this point>
    component: _33,
    // <unnamed>: …

    _start: usize,
    _end: usize,
};
const _31 = []const u8;
const _33 = *Component;
const _34 = []const u8;
fn _123(parser: *Parser) ParseError!_35 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const start = parser.cpos;
    _ = try _124(parser);
    return _125(parser, start) catch |e| switch (e) {
        error.Recoverable => return parser.unrecoverableError("lockin failed (126)"),
        else => return e,
    };
}
fn _125(parser: *Parser, start: usize) ParseError!_35 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);
    const _128 = try _127(parser);
    _ = try _129(parser);
    const end = parser.cpos;
    return _35{
        .component = _128,
        ._start = start,
        ._end = end,
    };
}
fn _124(parser: *Parser) ParseError!_31 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "(")).text;
}
fn _127(parser: *Parser) ParseError!_33 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _130 = try parseComponent(parser);
    const _131 = try parser.alloc.create(@TypeOf(_130));
    _131.* = _130;
    return _131;
}
fn _129(parser: *Parser) ParseError!_34 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, ")")).text;
}
pub const parseParens = _123;
const _47 = struct {
    // <unnamed>: …
    // <lockin past this point>
    bits: _44,
    // <unnamed>: …

    _start: usize,
    _end: usize,
};
const _37 = []const u8;
const _44 = []_42;
const _42 = union(enum) {
    string: _39,
    escape: _41,
};
const _39 = []const u8;
const _41 = []const u8;
const _46 = []const u8;
fn _132(parser: *Parser) ParseError!_47 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const start = parser.cpos;
    _ = try _133(parser);
    return _134(parser, start) catch |e| switch (e) {
        error.Recoverable => return parser.unrecoverableError("lockin failed (135)"),
        else => return e,
    };
}
fn _134(parser: *Parser, start: usize) ParseError!_47 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);
    const _137 = try _136(parser);
    _ = try _138(parser);
    const end = parser.cpos;
    return _47{
        .bits = _137,
        ._start = start,
        ._end = end,
    };
}
fn _133(parser: *Parser) ParseError!_37 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .string_start, null)).text;
}
fn _136(parser: *Parser) ParseError!_44 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    var resAL = std.ArrayList(_42).init(parser.alloc);
    while (true) {
        // :: parse 1 catch break
        try resAL.append(_139(parser) catch |e| switch (e) {
            else => return e,
            error.Recoverable => break,
        });
        // :: parse 2 catch break
        //_ = _140(parser) catch |e| switch(e) {else => return e, error.Recoverable => break};
    }
    return resAL.toOwnedSlice();
}
fn _139(parser: *Parser) ParseError!_42 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    blk: {
        return _42{
            .string = _141(parser) catch |e| switch (e) {
                else => return e,
                error.Recoverable => break :blk,
            },
        };
    }
    blk: {
        return _42{
            .escape = _142(parser) catch |e| switch (e) {
                else => return e,
                error.Recoverable => break :blk,
            },
        };
    }
    return parser.err("union field not matched f");
}
fn _141(parser: *Parser) ParseError!_39 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .string, null)).text;
}
fn _142(parser: *Parser) ParseError!_41 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .string_escape, null)).text;
}
fn _138(parser: *Parser) ParseError!_46 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .string_end, null)).text;
}
pub const parseString = _132;
const _59 = struct {
    // <unnamed>: …
    // <lockin past this point>
    name: _51,
    // <unnamed>: …
    args: _57,
    // <unnamed>: …

    _start: usize,
    _end: usize,
};
const _48 = []const u8;
const _51 = []const u8;
const _52 = []const u8;
const _57 = []_54;
const _54 = Component;
const _55 = []const u8;
const _58 = []const u8;
fn _143(parser: *Parser) ParseError!_59 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const start = parser.cpos;
    _ = try _144(parser);
    return _145(parser, start) catch |e| switch (e) {
        error.Recoverable => return parser.unrecoverableError("lockin failed (146)"),
        else => return e,
    };
}
fn _145(parser: *Parser, start: usize) ParseError!_59 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);
    const _148 = try _147(parser);
    _ = try _149(parser);
    const _151 = try _150(parser);
    _ = try _152(parser);
    const end = parser.cpos;
    return _59{
        .name = _148,
        .args = _151,
        ._start = start,
        ._end = end,
    };
}
fn _144(parser: *Parser) ParseError!_48 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "#")).text;
}
fn _147(parser: *Parser) ParseError!_51 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .identifier, null)).text;
}
fn _149(parser: *Parser) ParseError!_52 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "(")).text;
}
fn _150(parser: *Parser) ParseError!_57 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    var resAL = std.ArrayList(_54).init(parser.alloc);
    while (true) {
        // :: parse 1 catch break
        try resAL.append(_153(parser) catch |e| switch (e) {
            else => return e,
            error.Recoverable => break,
        });
        // :: parse 2 catch break
        _ = _154(parser) catch |e| switch (e) {
            else => return e,
            error.Recoverable => break,
        };
    }
    return resAL.toOwnedSlice();
}
fn _153(parser: *Parser) ParseError!_54 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return try parseComponent(parser);
}
fn _154(parser: *Parser) ParseError!_55 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, ",")).text;
}
fn _152(parser: *Parser) ParseError!_58 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, ")")).text;
}
pub const parseMagic = _143;
const _63 = union(enum) {
    nameset: _60,
    array: _61,
    optional: _62,
};
const _60 = *Nameset;
const _61 = *Array;
const _62 = *Optional;
fn _157(parser: *Parser) ParseError!_63 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    blk: {
        return _63{
            .nameset = _158(parser) catch |e| switch (e) {
                else => return e,
                error.Recoverable => break :blk,
            },
        };
    }
    blk: {
        return _63{
            .array = _159(parser) catch |e| switch (e) {
                else => return e,
                error.Recoverable => break :blk,
            },
        };
    }
    blk: {
        return _63{
            .optional = _160(parser) catch |e| switch (e) {
                else => return e,
                error.Recoverable => break :blk,
            },
        };
    }
    return parser.err("union field not matched f");
}
fn _158(parser: *Parser) ParseError!_60 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _161 = try parseNameset(parser);
    const _162 = try parser.alloc.create(@TypeOf(_161));
    _162.* = _161;
    return _162;
}
fn _159(parser: *Parser) ParseError!_61 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _163 = try parseArray(parser);
    const _164 = try parser.alloc.create(@TypeOf(_163));
    _164.* = _163;
    return _164;
}
fn _160(parser: *Parser) ParseError!_62 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _165 = try parseOptional(parser);
    const _166 = try parser.alloc.create(@TypeOf(_165));
    _166.* = _165;
    return _166;
}
pub const parseSuffixop = _157;
const _70 = struct {
    // <unnamed>: …
    // <lockin past this point>
    name: _68,
    // <unnamed>: …

    _start: usize,
    _end: usize,
};
const _64 = []const u8;
const _68 = ?_66;
const _66 = []const u8;
const _69 = []const u8;
fn _167(parser: *Parser) ParseError!_70 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const start = parser.cpos;
    _ = try _168(parser);
    return _169(parser, start) catch |e| switch (e) {
        error.Recoverable => return parser.unrecoverableError("lockin failed (170)"),
        else => return e,
    };
}
fn _169(parser: *Parser, start: usize) ParseError!_70 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);
    const _172 = try _171(parser);
    _ = try _173(parser);
    const end = parser.cpos;
    return _70{
        .name = _172,
        ._start = start,
        ._end = end,
    };
}
fn _168(parser: *Parser) ParseError!_64 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "<")).text;
}
fn _171(parser: *Parser) ParseError!_68 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return _174(parser) catch |e| switch (e) {
        else => return e,
        error.Recoverable => return null, // note that the called function already cancelBit'd so it's ok
    };
}
fn _174(parser: *Parser) ParseError!_66 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .identifier, null)).text;
}
fn _173(parser: *Parser) ParseError!_69 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, ">")).text;
}
pub const parseNameset = _167;
const _76 = struct {
    // <unnamed>: …
    // <lockin past this point>
    component: _74,
    // <unnamed>: …

    _start: usize,
    _end: usize,
};
const _71 = []const u8;
const _74 = ?_73;
const _73 = *Component;
const _75 = []const u8;
fn _175(parser: *Parser) ParseError!_76 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const start = parser.cpos;
    _ = try _176(parser);
    return _177(parser, start) catch |e| switch (e) {
        error.Recoverable => return parser.unrecoverableError("lockin failed (178)"),
        else => return e,
    };
}
fn _177(parser: *Parser, start: usize) ParseError!_76 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);
    const _180 = try _179(parser);
    _ = try _181(parser);
    const end = parser.cpos;
    return _76{
        .component = _180,
        ._start = start,
        ._end = end,
    };
}
fn _176(parser: *Parser) ParseError!_71 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "[")).text;
}
fn _179(parser: *Parser) ParseError!_74 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return _182(parser) catch |e| switch (e) {
        else => return e,
        error.Recoverable => return null, // note that the called function already cancelBit'd so it's ok
    };
}
fn _182(parser: *Parser) ParseError!_73 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _183 = try parseComponent(parser);
    const _184 = try parser.alloc.create(@TypeOf(_183));
    _184.* = _183;
    return _184;
}
fn _181(parser: *Parser) ParseError!_75 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "]")).text;
}
pub const parseArray = _175;
const _77 = []const u8;
fn _185(parser: *Parser) ParseError!_77 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "?")).text;
}
pub const parseOptional = _185;
const _78 = []const u8;
fn _186(parser: *Parser) ParseError!_78 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, ".")).text;
}
pub const parseForceStruct = _186;
