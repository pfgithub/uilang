file = expression[';'];

expression =
	| #operator((('+' '=')<pleq> | ('-' '=')<meq> | '='<eq>)<op>)<assignop>
	| #operator(('+'<plus> | '-'<minus>)<op>)<plusminusop>
	| #suffix(suffixop)<suffixop>
	| vardecl
	| function
	| returnstatement
	| htmlelement
	| htmlattribute
	| parens
	| block
	| variable
	| number
	| string
	| builtinexpr
;

builtinexpr = '@' identifier<name> '(' expression[',']<args> ')';

// TODO (':' expression<*>)?<ttype>
vardecl =
	('let'<let> | 'const'<const_> | 'state'<state> | 'trigger'<trigger>)<vartype> #lockin()
	identifier<name> ((':' expression<texpr>)<ttype> | ('=' expression<initv>)<auto>)<initmode>
;

// returns from a function, not a block or some parenthesis
returnstatement = 'return' expression;
htmlelement = '.' #lockin() identifier<tag> parens;
htmlattribute = ':' #lockin() identifier '=' expression;

// returns the last expression
parens = '(' #lockin() expression[',']<items> ')';
// can be broken out of (or returned if it's a function block)
block = '{' #lockin() expression[';']<decls> '}';

function = ('widget'<widget> | 'fn'<function>)<kind> #lockin() '(' identifier[',']<args> ')' expression;

variable = identifier<name> .;
number = :number;
string = :string_start<> #lockin() (:string | :string_escape<escape>)[]<bits> :string_end<>;

suffixop =
	| '!'<unused>
	| ('.' identifier)<fieldaccess>
	| ('(' expression[',']<args> ')')<call>
;

identifier = :identifier; // to allow for future expansion