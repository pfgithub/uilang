file = decl[';'];
decl =
	| fndecl
	| vardecl
	| returnlyn
	| assignment
	| expressionlyn
;
fndecl = fntype identifier '(' args ')' expression;
vardecl = vartype identifier ':' type '=' expression;
// in the future, this will be an operator
assignment = identifier ('='<eq> | ('+' '=')<pleq> | ('-' '=')<meq>)<op> expression;
returnlyn = 'return' expression;
expressionlyn = expression;

expression =
	| htmlelement
	| htmlattribute
	| parens // (a, b, c) returns c
	| block // {a; b; c} returns Ã¸. choice: make parens the same as block? like do fndecls and vardecls? sure why not
	| string
	| number
	| ilfn
	| variable
;

ilfn = '|' identifier[','] '|' parens;
variable = identifier;

parens = '(' decl[','] ')';
block = '{' decl[';'] '}';

args = decl[','];

// note: this still leaves room for . also being for union/enum literals, eg .enumkey or .unionkey{a=true}
htmlelement =
	'.' identifier parens (':' ':' htmleventhandler)?
;

// .button () :: onclick |e| alert(e)
htmleventhandler = identifier expression;

// just a normal expression, meaning you can do eg .div (if (a) :title="hi" else :placeholder="lo"), as expected.
htmlattribute =
	':' identifier '=' expression
;

vartype = 'state'<state> | 'trigger'<trigger> | 'const'<const_> | 'let'<let>;
fntype = 'widget'<widget> | 'fn'<fn_>;
type = 'i54';

identifier = :identifier;
number = :number;
string = :string_start<> (:string | :string_escape<escape>)[]<bits> :string_end<>;