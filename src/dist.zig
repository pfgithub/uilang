//! Autogenerated Code.
//! Manual edits may be overwritten on rebuild.

const tknzr = @import("tokenizer.zig");
const Token = tknzr.Token;
const Tokenizer = tknzr.Tokenizer;
const std = @import("std");
const Alloc = std.mem.Allocator;

const ___ = @This();
fn __aToString(comptime a: anytype) []const u8 {
    return @tagName(a); // todo support strings too
}
fn GetResType(comptime aname: []const u8) type {
    if (!@hasDecl(___, aname)) @compileError("unknown type " ++ aname);
    return @field(___, aname);
}
pub fn parse(alloc: *Alloc, code: []const u8, comptime a: anytype) !GetResType(__aToString(a)) {
    const aname = comptime __aToString(a);
    const ResType = GetResType(aname);
    const resfn = @field(___, "parse" ++ aname);

    var parser = Parser.init(alloc, code);
    defer parser.deinit();

    // TODO: @resultLocation().* = â€¦
    const outmain = try resfn(&parser);
    if ((try parser.nextToken())) |tok| {
        std.debug.panic("Remaining token: {}\n", .{tok});
    }
    return outmain;
}
pub const Parser = struct {
    alloc: *Alloc,
    tokenizer: Tokenizer,
    tokens: std.ArrayList(Token),
    tkpos: usize = 0,
    errors: ?[]const u8 = null,
    fn init(alloc: *Alloc, code: []const u8) Parser {
        return .{
            .alloc = alloc,
            .tokenizer = Tokenizer.init(code),
            .tokens = std.ArrayList(Token).init(alloc),
        };
    }
    fn deinit(parser: *Parser) void {
        parser.tokens.deinit();
    }
    fn err(parser: *Parser, message: []const u8) ParseError {
        parser.errors = message;
        return ParseError.ParseError;
    }
    fn nextToken(parser: *Parser) ParseError!?Token {
        if (parser.tkpos >= parser.tokens.items.len) {
            const nextToken_ = parser.tokenizer.next() catch return parser.err("bad token");
            try parser.tokens.append(nextToken_ orelse return null);
        }
        defer parser.tkpos += 1;
        return parser.tokens.items[parser.tkpos];
    }
    fn startBit(parser: Parser) usize {
        return parser.tkpos;
    }
    fn cancelBit(parser: *Parser, prevPos: usize) void {
        parser.tkpos = prevPos;
    }
};

pub const ParseError = error{
    OutOfMemory,
    ParseError,
};

fn _parseToken(parser: *Parser, tokenKind: Token.Type, expectedText: ?[]const u8) ParseError!Token {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const tok = (try parser.nextToken()) orelse return parser.err("err");
    if (tok.kind != tokenKind) return parser.err("err");
    if (expectedText) |txt| if (!std.mem.eql(u8, tok.text, txt)) return parser.err("err");

    return tok;
}

pub const Math = _11;
const _11 = union(enum) {
    plus_op: []_11,
    times_op: []_11,
    suffix_op: struct { _: *_11, suffixop: _8 },
    parens: _9,
    number: _10,
};
const _2 = []const u8;
const _5 = []const u8;
const _8 = *Suffixop;
const _9 = *Parens;
const _10 = *Number;
fn _12(parser: *Parser) ParseError!_11 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    var resAL = std.ArrayList(_11).init(parser.alloc);
    _ = _13(parser) catch |e| switch (e) {
        error.OutOfMemory => return e,
        error.ParseError => {},
    }; // optional first joiner
    while (true) {
        try resAL.append(_14(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => return parser.err("last or disallowed"),
        });
        _ = _13(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => break,
        };
    }
    if (resAL.items.len == 0) return parser.err("no items");
    if (resAL.items.len == 1) return resAL.items[0];

    return _11{ .plus_op = resAL.toOwnedSlice() };
}
fn _14(parser: *Parser) ParseError!_11 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);
    var resAL = std.ArrayList(_11).init(parser.alloc);
    _ = _15(parser) catch |e| switch (e) {
        error.OutOfMemory => return e,
        error.ParseError => {},
    }; // optional first joiner
    while (true) {
        try resAL.append(_16(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => return parser.err("last or disallowed"),
        });
        _ = _15(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => break,
        };
    }
    if (resAL.items.len == 0) return parser.err("no items");
    if (resAL.items.len == 1) return resAL.items[0];

    return _11{ .times_op = resAL.toOwnedSlice() };
}
fn _16(parser: *Parser) ParseError!_11 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);
    // 1: parse the structure
    const resc = try _18(parser);
    // 2: parse the suffixop[] and unwrap
    var topUnwrapped = resc;

    while (true) {
        const suffix = _17(parser) catch |e| switch (e) {
            error.OutOfMemory => return e,
            error.ParseError => break,
        };
        const allocated = try parser.alloc.create(@TypeOf(topUnwrapped));
        allocated.* = topUnwrapped;
        topUnwrapped = .{ .suffix_op = .{ ._ = allocated, .suffixop = suffix } };
    }
    return topUnwrapped;
}
fn _18(parser: *Parser) ParseError!_11 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);
    blk: {
        return _11{
            .parens = _19(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    blk: {
        return _11{
            .number = _20(parser) catch |e| switch (e) {
                error.OutOfMemory => return e,
                error.ParseError => break :blk,
            },
        };
    }
    return parser.err("union field not matched f");
}
fn _13(parser: *Parser) ParseError!_2 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "+")).text;
}
fn _15(parser: *Parser) ParseError!_5 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "*")).text;
}
fn _17(parser: *Parser) ParseError!_8 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _21 = try parseSuffixop(parser);
    const _22 = try parser.alloc.create(@TypeOf(_21));
    _22.* = _21;
    return _22;
}
fn _19(parser: *Parser) ParseError!_9 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _23 = try parseParens(parser);
    const _24 = try parser.alloc.create(@TypeOf(_23));
    _24.* = _23;
    return _24;
}
fn _20(parser: *Parser) ParseError!_10 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _25 = try parseNumber(parser);
    const _26 = try parser.alloc.create(@TypeOf(_25));
    _26.* = _25;
    return _26;
}
pub const parseMath = _12;
pub const Suffixop = _27;
const _27 = []const u8;
fn _28(parser: *Parser) ParseError!_27 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "!")).text;
}
pub const parseSuffixop = _28;
pub const Parens = _32;
const _32 = struct {
    math: _30,
};
const _29 = []const u8;
const _30 = *Math;
const _31 = []const u8;
fn _33(parser: *Parser) ParseError!_32 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    _ = try _34(parser);
    const _36 = try _35(parser);
    _ = try _37(parser);
    return _32{
        .math = _36,
    };
}
fn _34(parser: *Parser) ParseError!_29 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, "(")).text;
}
fn _35(parser: *Parser) ParseError!_30 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    const _38 = try parseMath(parser);
    const _39 = try parser.alloc.create(@TypeOf(_38));
    _39.* = _38;
    return _39;
}
fn _37(parser: *Parser) ParseError!_31 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .punctuation, ")")).text;
}
pub const parseParens = _33;
pub const Number = _40;
const _40 = []const u8;
fn _41(parser: *Parser) ParseError!_40 {
    const sb = parser.startBit();
    errdefer parser.cancelBit(sb);

    return (try _parseToken(parser, .identifier, "a")).text;
}
pub const parseNumber = _41;
